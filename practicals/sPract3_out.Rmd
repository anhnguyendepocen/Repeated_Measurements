## Practical 3: Marginal Models for Discrete Data
We start by loading the packages we will need for this practical and the data from 
[GitHub](https://github.com/drizopoulos/Repeated_Measurements). This is achieved with the
following commands:
```{r}
# packages
library("lattice")
library("geepack")
library("splines")

# data
con <- url("https://raw.github.com/drizopoulos/Repeated_Measurements/master/Data.RData")
load(con)
close(con)
```
```{r, echo = FALSE}
options(warn = (-1))
```

### Question 1
The following piece of code creates the dummy variable for abnormal prothrombin time:
```{r}
pbc2$Dicht_prothro <- as.numeric(with(pbc2, prothrombin < 11 | prothrombin > 13))
```

### Question 2
To examine graphically the shape of the probability of abnormal prothrombin time we can
smooth the scatterplot of the `Dicht_prothro`. Using function 
[xyplot()](https://goo.gl/cGSjZk) as in previous practicals, we first create the 
scatterplot of `Dicht_prothro` versus follow-up time, separately for placebo and 
D-penicillamine patients, and we include the loess curve:
```{r}
xyplot(Dicht_prothro ~ year | drug, data = pbc2,
       type = c("p", "smooth"), lwd = 2,
       xlab = "Time (years)", ylab = "Abnormal Prothrombin Time",
       scales = list(y = list(at = 0:1, labels = c("No", "Yes"))))
```

Note that due to the binary nature of `Dicht_prothro`, the actual data points do not 
provide any useful information. However, the loess smoother can still be used and recover
the shape of the probability of abnormal prothrombin time (**note:** the probability of
abnormal prothrombin time is actually the sample mean of the `Dicht_prothro` variable). 
For both treatment groups we observe a decrease in the probability of abnormal prothrombin
time during follow-up. We continue by producing the same plot but now splitting the panels
for males and females:
```{r}
xyplot(Dicht_prothro ~ year | sex, data = pbc2,
       type = c("p", "smooth"), lwd = 2,
       xlab = "Time (years)", ylab = "Abnormal Prothrombin Time",
       scales = list(y = list(at = 0:1, labels = c("No", "Yes"))))
```

This figure suggests that males have more stable evolutions, and that actually the females
are the ones who improve over time. Note that at this stage this is just an observation 
from just looking at the data. To make a formal conclusion we will need to test this 
conjecture. We finally produce the same scatterplot and we split at different age 
categories, namely, [25, 43], [43, 50], [50, 55], and [55, 80]. To achieve this we use 
function [cut()](https://goo.gl/t8xP1d), i.e.,
```{r}
xyplot(Dicht_prothro ~ year | cut(age, c(25, 43, 50, 55, 80)), data = pbc2,
       type = c("p", "smooth"), lwd = 2, as.table = TRUE,
       xlab = "Time (years)", ylab = "Abnormal Prothrombin Time",
       scales = list(y = list(at = 0:1, labels = c("No", "Yes"))))
```

We observe some subtle difference in the evolutions of the different age categories.

### Question 3
Based on the description of Question 3, we need to fit a GEE model with an exchangeable
working correlation matrix, and include in the mean structure the nonlinear effect
of time using natural cubic splines with 2 degrees of freedom (i.e., using function 
[ns()](https://goo.gl/zeAjzF)), the interaction of this nonlinear effect with drug and 
sex (while also including the main effects of these variables), the main effect of age, 
and its interaction with sex. This model is fitted with following call to function
[geeglm()](https://goo.gl/1S1uix) (**note:** we also need to set the `family` argument to
`binomial()`, and supply the `id` argument to identify the clusters, i.e., in this case 
the patients):
```{r}
fm_1 <- geeglm(Dicht_prothro ~ ns(year, 2) * (drug + sex) + age + age : sex, 
               family = binomial(), data = pbc2, id = id, corstr = "exchangeable")

summary(fm_1)
```

The `summary()` function produces a detailed output of the fitted model, with the 
parameter estimates, stadard errors and corresponding p-values.

### Question 4
We continue the analysis by re-fitting the model of Question 3 with the independence and 
autoregressive of order 1 working correlation matrices. This is done with the following 
calls to [geeglm()](https://goo.gl/1S1uix) by suitably changing the `corstr` argument:
```{r}
fm_2 <- geeglm(Dicht_prothro ~ ns(year, 2) * (drug + sex) + age + age : sex, 
               family = binomial(), data = pbc2, id = id, corstr = "independence")

fm_3 <- geeglm(Dicht_prothro ~ ns(year, 2) * (drug + sex) + age + age : sex, 
               family = binomial(), data = pbc2, id = id, corstr = "ar1")
```

We collect the estimated coefficients the two types of standard errors (i.e., sandwich and
naive) using similar code as in Section 4.5
```{r}
# parameters
betas <- cbind("independence" = coef(fm_2), 
            "exchangeable" = coef(fm_1),
            "AR1" = coef(fm_3))

# Sandwich standard errors
extractSEs <- function (model) sqrt(diag(model$geese$vbeta))
ses_sand <- cbind("independence" = extractSEs(fm_2), 
            "exchangeable" = extractSEs(fm_1),
            "AR1" = extractSEs(fm_3))

# Naive standard errors
extractSEs_naive <- function (model) sqrt(diag(model$geese$vbeta.naiv))
ses_naiv <- cbind("independence" = extractSEs_naive(fm_2), 
            "exchangeable" = extractSEs_naive(fm_1),
            "AR1" = extractSEs_naive(fm_3))
```

To make the coefficients' plot, we put the estimates and the calculated confidence 
intervals (both naive and robust) in a data frame:
```{r}
dat <- data.frame(
    est = c(betas), 
    lower_sand = unname(c(betas) - 1.96 * c(ses_sand)),
    lower_naiv = unname(c(betas) - 1.96 * c(ses_naiv)),
    upper_sand = unname(c(betas) + 1.96 * c(ses_sand)),
    upper_naiv = unname(c(betas) + 1.96 * c(ses_naiv)),
    parm = gl(11, 1, 33, labels = rownames(betas)),
    work_corr = gl(3, 11, labels = colnames(betas))
)
```

To produce the plot, we first define the `prepanel.ci2()` and `panel.ci2()` functions:
```{r}
prepanel.ci2 <- function (x, y, lx, ux, lx2, ux2, subscripts, ...) {
    x <- as.numeric(x)
    lx <- as.numeric(lx[subscripts])
    ux <- as.numeric(ux[subscripts])
    lx2 <- as.numeric(lx2[subscripts])
    ux2 <- as.numeric(ux2[subscripts])
    list(xlim = range(x, ux, lx, ux2, lx2, finite = TRUE))
}
panel.ci2 <- function (x, y, lx, ux, lx2, ux2, subscripts, pch = 16, ...) {
    x <- as.numeric(x)
    y <- as.numeric(y)
    lx <- as.numeric(lx[subscripts])
    ux <- as.numeric(ux[subscripts])
    lx2 <- as.numeric(lx2[subscripts])
    ux2 <- as.numeric(ux2[subscripts])
    panel.abline(h = c(unique(y)), 
                 col = "grey", lty = 2, lwd = 1.5)
    panel.arrows(lx, y, ux, y,
                 length = 0.1, unit = "native",
                 angle = 90, code = 3, lwd = 2, col = "blue")
    panel.arrows(lx2, y + 0.08, ux2, y + 0.08,
                 length = 0.1, unit = "native",
                 angle = 90, code = 3, lwd = 2, col = "magenta2")
    panel.xyplot(x, y, pch = pch, col = 2, cex = 0.9, ...)
    panel.xyplot(x, y + 0.08, pch = pch, col = 2, cex = 0.9, ...)
}
```

And following we call [dotplot()](https://goo.gl/7w7nrR):
```{r}
dotplot(work_corr ~  est | parm, lx = dat$lower_sand, lx2 = dat$lower_naiv, 
        ux = dat$upper_sand, ux2 = dat$upper_naiv,
        data = dat, xlab = "", prepanel = prepanel.ci2, panel = panel.ci2, 
        as.table = TRUE, scales = list(x = list(relation = "free")),
        key = simpleKey(c("Robust Standard Errors", "Naive Standard Errors"), 
                        points = FALSE, lines = TRUE, col = c("blue", "magenta2")))
```

A couple of observations:

* There are small differences in the estimates of the corresponding parameters across the 
different models.

* ...

### Question 5

```{r}
fm_3_noInt <- geeglm(Dicht_prothro ~ ns(year, 2) + drug + sex + age, 
               family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_noInt, fm_3)
```

```{r}
fm_3_IntDrug <- geeglm(Dicht_prothro ~ ns(year, 2) * sex + drug + age + age : sex, 
                       family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_IntDrug, fm_3)
```

```{r}
fm_3_IntSex <- geeglm(Dicht_prothro ~ ns(year, 2) * drug + sex + age, 
                       family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_IntSex, fm_3)
```

```{r}
fm_3_IntSexTime <- geeglm(Dicht_prothro ~ ns(year, 2) * drug + sex + age : sex, 
                       family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_IntSexTime, fm_3)
```

```{r}
fm_3_IntSexAge <- geeglm(Dicht_prothro ~ ns(year, 2) * (drug + sex) + age, 
                       family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_IntSexAge, fm_3)
```

### Question 6

```{r}
fm_3_IntSexAge_Lin <- geeglm(Dicht_prothro ~ year * (drug + sex) + age, 
                       family = binomial(), data = pbc2, id = id, corstr = "ar1")

anova(fm_3_IntSexAge_Lin, fm_3_IntSexAge)
```

### Question 7

```{r}
summary(fm_3_IntSexAge)
```

### Question 8

```{r}
effectPlotData <- function (object, newdata, orig_data) {
    form <- formula(object)
    namesVars <- all.vars(form)
    respVar <- namesVars[1]
    newdata[[respVar]] <- 0.01
    betas <- if (!inherits(object, "lme")) coef(object) else fixef(object)
    V <- if (inherits(object, "geeglm")) object$geese$vbeta else vcov(object)
    orig_data <- orig_data[complete.cases(orig_data[namesVars]), ]
    mfX <- model.frame(terms(form), data = orig_data)
    X <- model.matrix(attr(mfX, "terms"), newdata)
    pred <- c(X %*% betas)
    ses <- sqrt(diag(X %*% V %*% t(X)))
    newdata$pred <- pred
    newdata$low <- pred - 1.96 * ses
    newdata$upp <- pred + 1.96 * ses
    newdata
}
```

```{r}
newDF <- with(pbc2, expand.grid(
    year = seq(0, 12, length.out = 25),
    age = 49,
    drug = levels(drug),
    sex = levels(sex)
))
```

```{r}
xyplot(pred + low + upp ~ year | sex * drug, 
       data = effectPlotData(fm_3_IntSexAge, newDF, pbc2), 
       lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2, type = "l",
       xlab = "Follow-up time (years)",
       ylab = "log Odds")
```

```{r}
expit <- function (x) exp(x) / (1 + exp(x))
xyplot(expit(pred) + expit(low) + expit(upp) ~ year | sex * drug, 
       data = effectPlotData(fm_3_IntSexAge, newDF, pbc2), 
       lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2, type = "l",
       xlab = "Follow-up time (years)",
       ylab = "Probabilities")
```

### Question 9

```{r}
rowDiff <- function (object, newdata, orig_data, adjust.p = FALSE, ...) {
    form <- formula(object)
    namesVars <- all.vars(form)
    betas <- if (!inherits(object, "lme")) coef(object) else fixef(object)
    V <- if (inherits(object, "geeglm")) object$geese$vbeta else vcov(object)
    orig_data <- orig_data[complete.cases(orig_data[namesVars]), ]
    Terms <- delete.response(terms(form))
    mfX <- model.frame(Terms, data = orig_data)
    Terms_new <- attr(mfX, "terms")
    mfX_new <- model.frame(Terms_new, newdata, xlev = .getXlevels(Terms, mfX))
    X <- model.matrix(Terms_new, mfX_new)
    ind <- combn(nrow(X), 2)
    k <- ncol(ind)
    out <- matrix(0, k, 5)
    for (i in seq_len(k)) {
        XX <- X[ind[1, i], , drop = FALSE] - X[ind[2, i], , drop = FALSE]
        est <- drop(XX %*% betas)
        se <- sqrt(diag(XX %*% V %*% t(XX)))
        out[i, 1] <- est
        out[i, 2] <- se
        out[i, 3] <- est - 1.96 * se
        out[i, 4] <- est + 1.96 * se
        out[i, 5] <- 2 * pnorm(abs(est / se), lower.tail = FALSE)
    }
    if (k > 2 && adjust.p) {
        out[, 5] <- p.adjust(out[, 5], ...)
    }
    colnames(out) <- c("Diff", "Std.Err.", "95%low", "95%upp", "p-value")
    rownames(out) <- paste(ind[1, ], "-", ind[2, ])
    out
}
```

```{r}
nDF_male <- with(pbc2, expand.grid(
    year = c(2, 6, 8, 10), age = 55,
    drug = levels(drug)[2],
    sex = levels(sex)[1]
))
nDF_male
```

```{r}
rowDiff(fm_3_IntSexAge, nDF_male, pbc2)
```

```{r}
rowDiff(fm_3_IntSexAge, nDF_male, pbc2, adjust.p = TRUE)
```

```{r}
nDF_female <- with(pbc2, expand.grid(
    year = c(2, 6, 8, 10), age = 55,
    drug = levels(drug)[2],
    sex = levels(sex)[2]
))
nDF_female
```

```{r}
rowDiff(fm_3_IntSexAge, nDF_female, pbc2)
```

```{r}
rowDiff(fm_3_IntSexAge, nDF_female, pbc2, adjust.p = TRUE)
```
